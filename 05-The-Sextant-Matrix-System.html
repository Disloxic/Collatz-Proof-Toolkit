<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sextant Matrix System (Master Dashboard)</title>
    
    <script>
      window.MathJax = {
        tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
        svg: { fontCache: 'global' },
        startup: {
            ready: () => {
                MathJax.startup.defaultReady();
            }
        }
      };
    </script>
    
    <script id="MathJax-script" async src="lib/mathjax/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #2c3e50;
            --bg: #f8f9fa;
            --white: #ffffff;
            --border: #dee2e6;
            
            /* Text Colors */
            --col-green: #27ae60;
            --col-pink: #e91e63;
            --col-orange: #e67e22;
            --col-purple: #8e44ad;
            --col-red: #c0392b;
            --col-blue: #2980b9;

            /* UI Colors */
            --active-tab: #2c3e50;
            --inactive-tab: #95a5a6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            padding: 20px;
            color: #333;
            margin: 0;
        }

        h2 { text-align: center; color: var(--primary); margin-bottom: 5px; }
        .subtitle { text-align: center; color: #666; margin-bottom: 25px; font-style: italic;}

        /* --- MAIN MATRIX TABS (A-F) --- */
        .matrix-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .matrix-btn {
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid transparent;
            background-color: white;
            color: #7f8c8d;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-radius: 8px;
            min-width: 120px;
        }

        .matrix-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .matrix-btn.active {
            color: white; 
            border-color: transparent;
        }

        /* --- SUB-TABS (Layers) --- */
        .sub-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 0; 
            border-bottom: 1px solid var(--border);
            background: #fff;
            padding: 10px 20px 0 20px;
            border-radius: 12px 12px 0 0;
            max-width: 1200px;
            margin: 0 auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .sub-tab-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 4px solid transparent;
            font-size: 0.95rem;
            color: var(--inactive-tab);
            font-weight: 600;
            cursor: pointer;
            transition: color 0.2s;
        }

        .sub-tab-btn:hover { color: var(--primary); }
        
        .sub-tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary); 
        }

        /* --- CONTENT AREA --- */
        .content-container {
            background: white;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            max-width: 1200px;
            margin: 0 auto 40px auto;
            min-height: 400px;
            position: relative;
            overflow: hidden;
        }

        .layer-view {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s ease-in-out;
        }
        .layer-view.active { display: block; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .formula-bar {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
            color: #555;
            font-size: 1.1em;
            overflow-x: auto;
        }

        /* --- TABLE STYLING --- */
        .table-wrapper {
            width: 100%;
            overflow-x: auto;
            max-height: 60vh;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-variant-numeric: tabular-nums;
            font-size: 0.9em;
        }

        th, td {
            padding: 8px 12px;
            text-align: center;
            border-bottom: 1px solid #eee;
            border-right: 1px solid #f0f0f0;
            white-space: nowrap;
        }

        thead th {
            position: sticky;
            top: 0;
            z-index: 10;
            color: white;
            background-color: #34495e; 
        }

        td.row-idx {
            position: sticky;
            left: 0;
            background-color: #f8f9fa;
            font-weight: bold;
            border-right: 2px solid #ddd;
            z-index: 5;
            min-width: 40px;
        }

        /* --- TEXT COLORS --- */
        .text-green { color: var(--col-green); font-weight: bold; }
        .text-pink { color: var(--col-pink); font-weight: bold; }
        .text-orange { color: var(--col-orange); font-weight: bold; }
        .text-red { color: var(--col-red); font-weight: bold; }
        .text-blue { color: var(--col-blue); font-weight: bold; }
        
        .negative-val { color: #e74c3c; }
        .positive-val { color: #27ae60; }
        .is-float { color: #555; font-style: italic; }
        .coord-val { font-family: 'Consolas', monospace; font-size: 0.9em; }

        .legend-box {
            text-align: center;
            font-size: 0.9em;
            margin-bottom: 15px;
            color: #666;
        }
        .legend-box span { margin: 0 10px; }

/* Copyright Watermark Styles */
.copyright-watermark {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    display: flex;
    align-items: center;
    gap: 8px;
    
    /* Appearance */
    background-color: rgba(255, 255, 255, 0.9);
    padding: 6px 12px;
    border-radius: 6px;
    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
    
    font-family: sans-serif;
    font-size: 0.75rem;
    color: #4b5563;
    z-index: 9999;
    pointer-events: none;
}

.copyright-watermark a {
    pointer-events: auto;
    display: flex;
    text-decoration: none;
}

    </style>
</head>
<body>

    <h2>The Sextant Matrix System</h2>
    <div class="subtitle">Master Dashboard: Layers 1, 2, 2i, 3, 3i</div>

    <div class="matrix-tabs">
        <button class="matrix-btn" onclick="switchMatrix(0)"><span>Matrix A</span></button>
        <button class="matrix-btn" onclick="switchMatrix(1)"><span>Matrix B</span></button>
        <button class="matrix-btn" onclick="switchMatrix(2)"><span>Matrix C</span></button>
        <button class="matrix-btn" onclick="switchMatrix(3)"><span>Matrix D</span></button>
        <button class="matrix-btn" onclick="switchMatrix(4)"><span>Matrix E</span></button>
        <button class="matrix-btn" onclick="switchMatrix(5)"><span>Matrix F</span></button>
    </div>

    <div class="sub-tabs">
        <button class="sub-tab-btn active" onclick="switchLayer(0)">Layer 1: Values</button>
        <button class="sub-tab-btn" onclick="switchLayer(1)">Layer 2: Pred Values</button>
        <button class="sub-tab-btn" onclick="switchLayer(2)">Layer 2i: Pred Coords</button>
        <button class="sub-tab-btn" onclick="switchLayer(3)">Layer 3: Succ Values</button>
        <button class="sub-tab-btn" onclick="switchLayer(4)">Layer 3i: Succ Coords</button>
    </div>

    <div class="content-container">
        <div id="view-layer-0" class="layer-view active">
            <div class="formula-bar" id="formula-l0"></div>
            <div class="legend-box" id="l0-legend"></div>
            <div id="table-container-l0"></div>
        </div>

        <div id="view-layer-1" class="layer-view">
            <div class="formula-bar" id="formula-l1"></div>
            <div id="table-container-l1"></div>
        </div>

        <div id="view-layer-2" class="layer-view">
            <div class="formula-bar">
                Predecessor Coordinate System: $(V, q, u)$ derivation based on source Matrix $W$.
            </div>
            <div id="table-container-l2"></div>
        </div>

        <div id="view-layer-3" class="layer-view">
            <div class="formula-bar" id="formula-l3"></div>
            <div id="table-container-l3"></div>
        </div>

        <div id="view-layer-4" class="layer-view">
             <div class="formula-bar">
                Successor Coordinate System: $(M', i', j')$ derivation based on source Matrix $W$.
            </div>
            <div id="table-container-l4"></div>
        </div>
    </div>

    <script>
        /*******************************************************
         * 1. CONFIG & CONSTANTS
         *******************************************************/
        const CONFIG = { ROWS: 64, COLS: 12 };

        const MATRIX_DEF = [
            { name: 'A', color: '#87E2DE', darkText: true }, // A (0)
            { name: 'B', color: '#CBF583', darkText: true }, // B (1)
            { name: 'C', color: '#89E194', darkText: true }, // C (2)
            { name: 'D', color: '#D88DE5', darkText: true }, // D (3)
            { name: 'E', color: '#F193E0', darkText: true }, // E (4)
            { name: 'F', color: '#ED94AC', darkText: true }  // F (5)
        ];

        const FORMULAS_TXT = [
            { // A
                L0: String.raw`$\mathbf{A}^{(1)}_{i,j} = R_{1,j} + 6p(i-1)$`, 
                L1: String.raw`$\mathbf{A}^{(2)}_{i,j} = 4\mathbf{A}^{(1)}_{i,j} + 1$`, 
                L3: String.raw`$\mathbf{A}^{(3)}_{i,j} = \frac{3\mathbf{A}^{(1)}_{i,j} + 1}{p}$` 
            },
            { // B
                L0: String.raw`$\mathbf{B}^{(1)}_{i,j} = R_{2,j} + 6p(i-1)$`, 
                L1: String.raw`$\mathbf{B}^{(2)}_{i,j} = \frac{4\mathbf{B}^{(1)}_{i,j} - 1}{3}$`, 
                L3: String.raw`$\mathbf{B}^{(3)}_{i,j} = \frac{3\mathbf{B}^{(1)}_{i,j} + 1}{p}$` 
            },
            { // C
                L0: String.raw`$\mathbf{C}^{(1)}_{i,j} = R_{3,j} + 6p(i-1)$`, 
                L1: String.raw`$\mathbf{C}^{(2)}_{i,j} = \frac{2\mathbf{C}^{(1)}_{i,j} - 1}{3}$`, 
                L3: String.raw`$\mathbf{C}^{(3)}_{i,j} = \frac{3\mathbf{C}^{(1)}_{i,j} + 1}{p}$` 
            },
            { // D
                L0: String.raw`$\mathbf{D}^{(1)}_{i,j} = R_{4,j} + 12p(i-1)$`, 
                L1: String.raw`$\mathbf{D}^{(2)}_{i,j} = 4\mathbf{D}^{(1)}_{i,j} + 1$`, 
                L3: String.raw`$\mathbf{D}^{(3)}_{i,j} = \frac{3\mathbf{D}^{(1)}_{i,j} + 1}{2p}$` 
            },
            { // E
                L0: String.raw`$\mathbf{E}^{(1)}_{i,j} = R_{5,j} + 12p(i-1)$`, 
                L1: String.raw`$\mathbf{E}^{(2)}_{i,j} = \frac{4\mathbf{E}^{(1)}_{i,j} - 1}{3}$`, 
                L3: String.raw`$\mathbf{E}^{(3)}_{i,j} = \frac{3\mathbf{E}^{(1)}_{i,j} + 1}{2p}$` 
            },
            { // F
                L0: String.raw`$\mathbf{F}^{(1)}_{i,j} = R_{6,j} + 12p(i-1)$`, 
                L1: String.raw`$\mathbf{F}^{(2)}_{i,j} = \frac{2\mathbf{F}^{(1)}_{i,j} - 1}{3}$`, 
                L3: String.raw`$\mathbf{F}^{(3)}_{i,j} = \frac{3\mathbf{F}^{(1)}_{i,j} + 1}{2p}$` 
            }
        ];

        // --- SUCCESSOR DATA (For Layer 3i) ---
        const ABC_BM = [['C','F','F'],['C','C','C'],['C','F','C'],['F','C','C'],['C','C','F'],['F','C','C'],['C','F','C'],['F','C','C'],['C','F','F'],['C','C','C'],['C','F','F'],['F','C','C'],['C','C','F'],['C','C','C'],['C','F','C'],['F','C','C'],['C','F','F'],['C','C','C'],['C','F','F'],['F','C','C'],['C','C','F'],['F','C','C'],['C','F','C'],['F','C','C'],['C','C','F'],['C','C','C'],['C','F','F'],['F','C','C'],['C','C','F'],['F','C','C'],['C','F','C'],['F','C','C'],['C','F','F'],['C','C','C'],['C','F','C'],['F','C','C'],['C','C','F'],['F','C','C'],['C','F','C'],['F','C','C'],['C','C','F'],['C','C','C'],['C','F','F'],['F','C','C'],['C','C','F'],['C','C','C'],['C','F','C'],['F','C','C'],['C','F','F'],['C','C','C'],['C','F','F'],['F','C','C'],['C','C','F'],['F','C','C'],['C','F','C'],['F','C','C'],['C','C','F'],['C','C','C'],['C','F','F'],['F','C','C'],['C','C','F'],['F','C','C'],['C','F','C'],['F','C','C']];
        const ABC_Bj = [[1,2,1],[2,1,1],[1,1,3],[1,1,1],[1,2,1],[2,1,1],[1,1,2],[1,1,1],[1,3,1],[2,1,1],[1,1,2],[1,1,1],[1,2,1],[3,1,1],[1,1,2],[1,1,1],[1,2,1],[2,1,1],[1,1,5],[1,1,1],[1,2,1],[2,1,1],[1,1,2],[1,1,1],[1,3,1],[2,1,1],[1,1,2],[1,1,1],[1,2,1],[3,1,1],[1,1,2],[1,1,1],[1,2,1],[2,1,1],[1,1,3],[1,1,1],[1,2,1],[2,1,1],[1,1,2],[1,1,1],[1,4,1],[2,1,1],[1,1,2],[1,1,1],[1,2,1],[3,1,1],[1,1,2],[1,1,1],[1,2,1],[2,1,1],[1,1,3],[1,1,1],[1,2,1],[2,1,1],[1,1,2],[1,1,1],[1,3,1],[2,1,1],[1,1,2],[1,1,1],[1,2,1],[4,1,1],[1,1,2],[1,1,1]];
        const DEF_BM = [['E','B','B'],['B','E','B'],['E','B','E'],['B','B','B'],['E','B','E'],['B','E','B'],['B','B','E'],['B','E','B'],['E','B','B'],['B','E','B'],['B','B','E'],['B','B','B'],['E','B','E'],['B','E','B'],['B','B','E'],['B','E','B'],['E','B','B'],['B','E','B'],['E','B','E'],['B','B','B'],['E','B','B'],['B','E','B'],['B','B','E'],['B','E','B'],['E','B','B'],['B','E','B'],['B','B','E'],['B','B','B'],['E','B','E'],['B','E','B'],['B','B','E'],['B','B','B'],['E','B','B'],['B','E','B'],['E','B','E'],['B','B','B'],['E','B','E'],['B','E','B'],['B','B','E'],['B','E','B'],['E','B','B'],['B','E','B'],['B','B','E'],['B','B','B'],['E','B','E'],['B','E','B'],['B','B','E'],['B','B','B'],['E','B','B'],['B','E','B'],['E','B','E'],['B','B','B'],['E','B','B'],['B','E','B'],['B','B','E'],['B','E','B'],['E','B','B'],['B','E','B'],['E','B','E'],['B','B','B'],['E','B','E'],['B','E','B'],['B','B','E'],['B','B','B']];
        const DEF_Bj = [[1,1,2],[1,1,1],[2,1,1],[1,2,1],[1,1,4],[1,1,1],[2,1,1],[1,2,1],[1,1,2],[1,1,1],[3,1,1],[1,2,1],[1,1,2],[1,1,1],[2,1,1],[1,3,1],[1,1,2],[1,1,1],[2,1,1],[1,2,1],[1,1,3],[1,1,1],[2,1,1],[1,2,1],[1,1,2],[1,1,1],[4,1,1],[1,2,1],[1,1,2],[1,1,1],[2,1,1],[1,3,1],[1,1,2],[1,1,1],[2,1,1],[1,2,1],[1,1,3],[1,1,1],[2,1,1],[1,2,1],[1,1,2],[1,1,1],[3,1,1],[1,2,1],[1,1,2],[1,1,1],[2,1,1],[1,5,1],[1,1,2],[1,1,1],[2,1,1],[1,2,1],[1,1,3],[1,1,1],[2,1,1],[1,2,1],[1,1,2],[1,1,1],[3,1,1],[1,2,1],[1,1,2],[1,1,1],[2,1,1],[1,3,1]];
        const P_CONST = { 'A': { M: 96, D: 2 }, 'B': { M: 48, D: 4 }, 'C': { M: 24, D: 8 }, 'D': { M: 12, D: 16 }, 'E': { M: 6, D: 32 }, 'F': { M: 3, D: 64 }, 'G': { M: 3, D: 64 } };
        const ABC_PATTERNS = { 1: { 'A': { S: 1, d: 1 }, 'B': { S: 3, d: 4 }, 'C': { S: 1, d: 2 }, 'D': { S: 2, d: 6 }, 'E': { S: 2, d: 14 }, 'F': { S: 2, d: 30 }, 'G': { d: 62 } }, 2: { 'A': { S: 2, d: 2 }, 'B': { S: 2, d: 3 }, 'C': { S: 2, d: 5 }, 'D': { S: 1, d: 1 }, 'E': { S: 3, d: 25 }, 'F': { S: 1, d: 9 }, 'G': { d: 41 } }, 3: { 'A': { S: 3, d: 2 }, 'B': { S: 1, d: 1 }, 'C': { S: 3, d: 7 }, 'D': { S: 3, d: 11 }, 'E': { S: 1, d: 3 }, 'F': { S: 3, d: 51 }, 'G': { d: 19 } } };
        const DEF_PATTERNS = { 1: { 'A': { S: 2, d: 2 }, 'B': { S: 1, d: 1 }, 'C': { S: 3, d: 7 }, 'D': { S: 1, d: 3 }, 'E': { S: 1, d: 11 }, 'F': { S: 3, d: 59 }, 'G': { d: 27 } }, 2: { 'A': { S: 1, d: 1 }, 'B': { S: 2, d: 2 }, 'C': { S: 2, d: 4 }, 'D': { S: 2, d: 8 }, 'E': { S: 3, d: 32 }, 'F': { S: 1, d: 16 }, 'G': { d: 48 } }, 3: { 'A': { S: 3, d: 2 }, 'B': { S: 3, d: 3 }, 'C': { S: 1, d: 1 }, 'D': { S: 3, d: 13 }, 'E': { S: 2, d: 21 }, 'F': { S: 2, d: 37 }, 'G': { d: 5 } } };

        /*******************************************************
         * 2. CALCULATION LOGIC
         *******************************************************/
        
        // --- BASIC HELPERS ---
        function mod(n, m) { return ((n % m) + m) % m; }
        const getParams = (j) => {
            const fourPowJ = BigInt(4) ** BigInt(j);
            const h = (BigInt(4) * fourPowJ - 1n) / 3n;
            const p = fourPowJ / 2n;
            return { h, p };
        };

        // --- LAYER 1 & 2 & 3 GENERATION (Grid Based) ---
        function getRValueBig(rowIdx, j, h, p) {
            const rCol = Number((j - 1n) % 3n);
            const definitions = [
                [(h-p), (h+3n*p), (h+p)],     
                [(h+p), (h-p), (h+3n*p)],     
                [(h+3n*p), (h+p), (h-p)],     
                [(h+2n*p), (h+6n*p), (h-2n*p)], 
                [(h-2n*p), (h+2n*p), (h+6n*p)], 
                [(h+6n*p), (h-2n*p), (h+2n*p)]  
            ];
            return definitions[rowIdx][rCol];
        }

        function generateData(mIdx, type) {
            let data = [];
            const isLeftCol = mIdx < 3; 

            for (let i = 1; i <= CONFIG.ROWS; i++) {
                let row = [];
                for (let j = 1; j <= CONFIG.COLS; j++) {
                    const i_big = BigInt(i);
                    const j_big = BigInt(j);
                    const { h, p } = getParams(j_big);
                    const rVal = getRValueBig(mIdx, j_big, h, p);
                    const multiplier = isLeftCol ? 6n : 12n;
                    
                    // Layer 1 Value
                    const L1 = rVal + (multiplier * p * (i_big - 1n));

                    if (type === 'L0') { // Layer 1 Values
                        row.push(Number(L1)); // converting to number for rendering if safe, usually fine for display grid
                    } 
                    else if (type === 'L1') { // Layer 2 Values (Predecessor n)
                        let L2;
                        if (mIdx === 0 || mIdx === 3) L2 = 4n * L1 + 1n;
                        else if (mIdx === 1 || mIdx === 4) L2 = (4n * L1 - 1n) / 3n;
                        else L2 = (2n * L1 - 1n) / 3n;
                        row.push(Number(L2));
                    } 
                    else if (type === 'L3') { // Layer 3 Values (Successor n)
                        let L3;
                        const den = isLeftCol ? p : (2n * p);
                        L3 = (3n * L1 + 1n) / den;
                        // Use string if it's huge, otherwise number
                        row.push(Number(L3));
                    }
                    else if (type === 'L2_COORD') { // Layer 2i Predecessor Coords
                        const res = calculatePredecessor(mIdx, i_big, j_big, L1);
                        row.push(res); // returns string
                    }
                    else if (type === 'L3_COORD') { // Layer 3i Successor Coords
                        const res = calculateSuccessor(mIdx, i, j); // using numbers for pattern logic
                        row.push(res); // returns string
                    }
                }
                data.push(row);
            }
            return data;
        }

        // --- PREDECESSOR COORDINATE LOGIC ---
        function calculatePredecessor(mIdx, i, j, L1_val) {
            const matrixMap = ['A','B','C','D','E','F'];
            const M = matrixMap[mIdx];
            
            // 1. Calculate L2 Value
            let L2_val;
            if (M === 'A' || M === 'D') L2_val = 4n * L1_val + 1n;
            else if (M === 'B' || M === 'E') L2_val = (4n * L1_val - 1n) / 3n;
            else L2_val = (2n * L1_val - 1n) / 3n;

            // 2. Identify V
            let V;
            if (M === 'A') V = 'B';
            else if (M === 'D') V = 'E';
            else {
                const cycleRow = Number((i - 1n) % 3n);
                const cycleCol = Number((j - 1n) % 9n);
                const cycles = {
                    'B': [['D','F','E','E','D','F','F','E','D'],['E','D','F','F','E','D','D','F','E'],['F','E','D','D','F','E','E','D','F']],
                    'C': [['B','B','C','A','A','B','C','C','A'],['A','A','B','C','C','A','B','B','C'],['C','C','A','B','B','C','A','A','B']],
                    'E': [['E','E','D','F','F','E','D','D','F'],['D','D','F','E','E','D','F','F','E'],['F','F','E','D','D','F','E','E','D']],
                    'F': [['C','A','A','B','C','C','A','B','B'],['A','B','B','C','A','A','B','C','C'],['B','C','C','A','B','B','C','A','A']]
                };
                V = cycles[M][cycleRow][cycleCol];
            }

            // 3. Calculate Coords
            let q, u;
            if (M === 'A' || M === 'D') {
                q = i;
                u = j + 1n;
            } else {
                // V(1)_1,1 base
                const j_v = 1n;
                const { h, p } = getParams(j_v);
                const R_struct = [(h-p),(h+p),(h+3n*p),(h+2n*p),(h-2n*p),(h+6n*p)]; // A,B,C,D,E,F in order
                const vIdx = matrixMap.indexOf(V);
                const V1_1_1 = R_struct[vIdx];

                const diff = L2_val - V1_1_1;
                u = 1n;

                if (M === 'B' || M === 'E') {
                    q = 1n + (diff / 24n);
                } else {
                    // Case C/F: multiply by 2 before divide
                    q = 1n + (2n * diff) / 24n;
                }
            }
            return `(${V}, ${q}, ${u})`;
        }

        // --- SUCCESSOR COORDINATE LOGIC ---
        function identifyPattern(r, patternMap) {
            const checkOrder = ['F', 'E', 'D', 'C', 'B', 'A'];
            for (let name of checkOrder) {
                let p = patternMap[name];
                let params = P_CONST[name];
                if (mod(r - p.d, params.D) === 0) return { name: name, ...p, ...params };
            }
            return null;
        }

        function calculateSuccessor(mIdx, i_in, j_in) {
            const matrixMap = ['A','B','C','D','E','F'];
            const M_in = matrixMap[mIdx];
            const isABC = (mIdx < 3);

            let j_0;
            if (M_in === 'A' || M_in === 'D') j_0 = j_in + 1;
            else if (M_in === 'C' || M_in === 'F') j_0 = j_in - 1;
            else j_0 = j_in;

            let i_curr = i_in;
            let j_curr = j_0;
            let C = 0;
            let loops = 0;

            // Singularity Resolution
            while (true) {
                loops++;
                if (loops > 200) return "Err";

                let k = mod(j_curr - 1, 3) + 1;
                const patterns = isABC ? ABC_PATTERNS : DEF_PATTERNS;
                const G_params = patterns[k]['G'];
                const dist = mod(i_curr - G_params.d, 64);
                
                if (dist === 0) {
                    let i_next = (i_curr - G_params.d) / 64 + 1;
                    let shift = isABC ? 2 : 1;
                    j_curr += shift;
                    C += 3;
                    i_curr = i_next;
                } else {
                    break;
                }
            }

            // Lookup
            const r = mod(i_curr - 1, 64) + 1;
            const k = mod(j_curr - 1, 3) + 1;
            
            const MatrixTable = isABC ? ABC_BM : DEF_BM;
            const M_prime = MatrixTable[r-1][k-1];

            const ColTable = isABC ? ABC_Bj : DEF_Bj;
            const j_base = ColTable[r-1][k-1];
            const j_prime = j_base + C;

            const patternMap = isABC ? ABC_PATTERNS[k] : DEF_PATTERNS[k];
            const activePattern = identifyPattern(r, patternMap);
            
            if (!activePattern) return "Pat Err";

            const blockIndex = Math.floor((i_curr - 1) / 64);
            const modPart = mod(i_curr - activePattern.d, 64); 
            const patternTerm = Math.floor(modPart / activePattern.D);
            const i_prime = activePattern.S + (activePattern.M * blockIndex) + (3 * patternTerm);

            return `(${M_prime}, ${i_prime}, ${j_prime})`;
        }

        /*******************************************************
         * 3. UI RENDERING
         *******************************************************/
        
        let currentMatrixIdx = 0;
        let currentLayerIdx = 0;

        function buildTableHTML(data, type) {
            const mColor = MATRIX_DEF[currentMatrixIdx].color;
            const darkHead = MATRIX_DEF[currentMatrixIdx].darkText;
            
            let html = `<div class="table-wrapper"><table style="border-top: 3px solid ${mColor}"><thead><tr><th style="background:${mColor}; color:${darkHead ? '#000':'#fff'}; left:0; z-index:11;">i \\ j</th>`;
            
            for(let j=1; j<=CONFIG.COLS; j++) {
                html += `<th style="background:${mColor}; color:${darkHead ? '#000':'#fff'}">${j}</th>`;
            }
            html += `</tr></thead><tbody>`;

            data.forEach((row, i) => {
                html += `<tr><td class="row-idx">${i+1}</td>`;
                row.forEach((val, colIdx) => {
                    const j = colIdx + 1;
                    let classes = [];
                    let displayVal = val;
                    let cellStyle = '';

                    // --- LAYER 1: Simple One-Color Fill Logic ---
                    if (type === 'L0') {
                         const mat = MATRIX_DEF[currentMatrixIdx];
                         // Fill every cell with the matrix's color, but NOT bold
                         cellStyle = `background-color: ${mat.color}; color: #000;`; 
                         displayVal = val.toLocaleString();
                    }
                    
                    // --- LAYERS 2 & 3: Numeric Styling + Dynamic Color based on Target Matrix ---
                    else if (type === 'L1' || type === 'L3') { 
                        // Numeric Formatting
                        if (val < 0) classes.push('negative-val');
                        else if (val > 0) classes.push('positive-val');
                        
                        if (!Number.isInteger(val)) {
                            classes.push('is-float');
                            displayVal = val.toLocaleString(undefined, { maximumFractionDigits: 2 });
                        } else {
                            displayVal = val.toLocaleString();
                        }

                        // Dynamic Coloring Logic
                        let targetMatrix = null;

                        if (type === 'L1') { 
                            // Layer 2 (Pred Values) -> Needs Layer 2i (Pred Coord) logic
                            // Re-calculate the source L1 value to derive the Coord
                            const i_big = BigInt(i + 1);
                            const j_big = BigInt(colIdx + 1);
                            const { h, p } = getParams(j_big);
                            const rVal = getRValueBig(currentMatrixIdx, j_big, h, p);
                            const isLeftCol = currentMatrixIdx < 3;
                            const multiplier = isLeftCol ? 6n : 12n;
                            const L1_val = rVal + (multiplier * p * (i_big - 1n));
                            
                            const coordStr = calculatePredecessor(currentMatrixIdx, i_big, j_big, L1_val);
                            const match = coordStr.match(/^\(([A-F])/)
                            if (match) targetMatrix = match[1];

                        } else {
                            // Layer 3 (Succ Values) -> Needs Layer 3i (Succ Coord) logic
                            const coordStr = calculateSuccessor(currentMatrixIdx, i + 1, colIdx + 1);
                             const match = typeof coordStr === 'string' ? coordStr.match(/^\(([A-F])/) : null;
                             if (match) targetMatrix = match[1];
                        }

                        if (targetMatrix) {
                             const mat = MATRIX_DEF.find(m => m.name === targetMatrix);
                             if (mat) {
                                 // Add color, ensure text is readable (black)
                                 cellStyle = `background-color: ${mat.color}; color: #000;`;
                             }
                        }
                    } 
                    
                    // --- COORDINATE LAYERS (2i & 3i): Color by Source Letter ---
                    else if (type === 'COORD') { 
                        classes.push('coord-val');
                        const match = typeof val === 'string' ? val.match(/^\(([A-F])/) : null;
                        
                        if (match) {
                            const letter = match[1];
                            const mat = MATRIX_DEF.find(m => m.name === letter);
                            if (mat) {
                                cellStyle = `background-color: ${mat.color}; color: #000;`;
                            }
                        } else {
                            classes.push('text-blue');
                        }
                    }

                    html += `<td class="${classes.join(' ')}" style="${cellStyle}">${displayVal}</td>`;
                });
                html += `</tr>`;
            });
            html += `</tbody></table></div>`;
            return html;
        }

        function updateUI() {
            // Update Tab States
            const def = MATRIX_DEF[currentMatrixIdx];
            document.querySelectorAll('.matrix-btn').forEach((btn, idx) => {
                if (idx === currentMatrixIdx) {
                    btn.classList.add('active');
                    btn.style.backgroundColor = def.color;
                    btn.style.color = def.darkText ? '#000' : '#fff';
                    btn.style.borderColor = def.color;
                } else {
                    btn.classList.remove('active');
                    btn.style.backgroundColor = 'white';
                    btn.style.color = '#7f8c8d';
                    btn.style.borderColor = 'transparent';
                }
            });

            document.querySelectorAll('.sub-tab-btn').forEach((btn, idx) => {
                if (idx === currentLayerIdx) {
                    btn.classList.add('active');
                    btn.style.borderBottomColor = def.color;
                    btn.style.color = def.color; 
                } else {
                    btn.classList.remove('active');
                    btn.style.borderBottomColor = 'transparent';
                    btn.style.color = '#6c757d';
                }
            });

            document.querySelectorAll('.layer-view').forEach((view, idx) => {
                if(idx === currentLayerIdx) view.classList.add('active');
                else view.classList.remove('active');
            });

            // Generate Content based on active layer
            let data, type;
            const formulas = FORMULAS_TXT[currentMatrixIdx];

            if (currentLayerIdx === 0) { // L1 (Values)
                data = generateData(currentMatrixIdx, 'L0');
                document.getElementById('formula-l0').innerHTML = formulas.L0;
                document.getElementById('table-container-l0').innerHTML = buildTableHTML(data, 'L0');
                
                // Simplified Legend for L0
                document.getElementById('l0-legend').innerHTML = '<span style="font-weight:bold;">All cells colored by Matrix ID</span>';

            } else if (currentLayerIdx === 1) { // L2 (Pred Values)
                data = generateData(currentMatrixIdx, 'L1');
                document.getElementById('formula-l1').innerHTML = formulas.L1;
                document.getElementById('table-container-l1').innerHTML = buildTableHTML(data, 'L1');

            } else if (currentLayerIdx === 2) { // L2i (Pred Coords)
                data = generateData(currentMatrixIdx, 'L2_COORD');
                document.getElementById('table-container-l2').innerHTML = buildTableHTML(data, 'COORD');

            } else if (currentLayerIdx === 3) { // L3 (Succ Values)
                data = generateData(currentMatrixIdx, 'L3');
                document.getElementById('formula-l3').innerHTML = formulas.L3;
                document.getElementById('table-container-l3').innerHTML = buildTableHTML(data, 'L3');

            } else if (currentLayerIdx === 4) { // L3i (Succ Coords)
                data = generateData(currentMatrixIdx, 'L3_COORD');
                document.getElementById('table-container-l4').innerHTML = buildTableHTML(data, 'COORD');
            }

            // Render MathJax
            if(window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise();
            }
        }

        window.switchMatrix = function(idx) {
            currentMatrixIdx = idx;
            updateUI();
        };

        window.switchLayer = function(idx) {
            currentLayerIdx = idx;
            updateUI();
        };

        window.onload = () => {
            console.log("Master Dashboard Initialized");
            updateUI();
        };
    </script>
</body>

<div class="copyright-watermark">
    &copy; 2026 <strong>David Potts</strong> | MIT License
	<a href="https://orcid.org/0009-0008-1403-8962" target="_blank" style="display: flex;">
    <svg xmlns="http://www.w3.org/2000/svg" width="65" height="20" role="img" aria-label="ORCID"><title>ORCID</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="65" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="0" height="20" fill="#555"/><rect x="0" width="65" height="20" fill="#a6ce39"/><rect width="65" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><image x="5" y="3" width="14" height="14" href="lib/id.svg"/><text aria-hidden="true" x="415" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="370">ORCID</text><text x="415" y="140" transform="scale(.1)" fill="#fff" textLength="370">ORCID</text></g></svg>
    </a>
</div>

</html>